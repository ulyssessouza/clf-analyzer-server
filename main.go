package main

import (
	"flag"

	"github.com/ulyssessouza/clf-analyzer-server/core"
	"github.com/ulyssessouza/clf-analyzer-server/data"
	_ "github.com/ulyssessouza/clf-analyzer-server/docs" // docs is generated by Swag CLI
	"github.com/ulyssessouza/clf-analyzer-server/http"
)

var Port = flag.Int("port", 8000, "port to listen on")
var tailFlag = flag.String("tail", "stdin", "file to tail")

func closeConnections() {
	// TODO Gracefully close all open connections
	// for all conns c {
	//     c.WriteControl(CloseMessage, FormatCloseMessage(CloseGoingAway, ""), time.Now().Add(1 * time.Second))
	// }
}

func startGoroutines(inputLineChan *chan string, cacheRefreshChan *chan int) {
	// Choose input mode
	if tailFlag != nil && *tailFlag != "" && *tailFlag != "stdin" {
		go inputFromTail(inputLineChan, *tailFlag)
	} else {
		go inputFromStdIn(inputLineChan)
	}

	go core.StartIngestion(inputLineChan) // Starts ingesting lines included in the channel by the previous goroutines

	go http.StartListenTicks(cacheRefreshChan) // Listen ticks
	go data.StartScoreLoop(cacheRefreshChan)
	go data.StartAlertLoop(cacheRefreshChan)
	go data.StartHitsLoop(cacheRefreshChan)
	go core.UpdateAlert()
}

func main() {
	flag.Parse()

	db := data.OpenDb("sqlite_clf_analyzer.db")
	data.InitDb(db)
	defer data.CloseDb()

	var cacheRefreshChan = make(chan int) // data.ticker -> SQL select -> scoreChannels.Broadcast()
	var inputLineChan = make(chan string) // Channel used to make the input source generic
	defer close(inputLineChan)
	defer close(cacheRefreshChan)

	startGoroutines(&inputLineChan, &cacheRefreshChan)
	http.StartHttp(*Port)
}
